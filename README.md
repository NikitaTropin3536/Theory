Теория, которая поможет при написании контрольной по материалу 3 модуля
(+ советы по выполнению некоторых заданий)

(только самое необходимое - ведь вы и так знаете, как написать try cathc + есть страничка в учебнике)

Итак, темы которые будут затронуты в контрольной (берем пробный вариант):
  1. UML диаграммы - первые 2 задания;
  2. класс File и класс Exception;
  3. Исключения;
  4. Logcat;
  5. Throws - для чего нужно?;
  6. Программа с try catch;
  7. Фрагменты;
  8. Внутренние и анонимные классы;
  9. Потоки в Android;
  10. Методы по управлению потоками;
  11. Программа с потоками;
  12. Canvas и рисунки;
  13. SurfaceView, SurfaceHolder.Callback и его методы;
  14. Android приложение;

1) UML диаграммы
       Имя абстрактного класса записывается курсивом.
       Стрелочки, которые выражают отношение диаграмм class - ов -> https://prog-cpp.ru/uml-classes/?ysclid=ldkfheuh74865586657 (прокручиваем вниз и находим стрелочки)
          + public
          - private
          # protected
      Базовый ккласс или суперкласс - это класс, который служит основой для другого (класс родитель)
      Если просят построить описание класса по диаграмме, и он наследуется от другого класса, мы имееем право использовать extends;
      
2) класс File и класс Exception
    методы File и Exception - гляньте в учебнике - там оч хорошо написано. Все по делу
    
    Теперь...
    
    Чтение файла и запись в файл
    
    1. все экземпляры классов FileReader, FileWriter и т п - могут выбрасывать исключение наследник класса Exception
    
    2. void test() throws IOException {
      PrintWriter writer = new PrintWriter(new PrintWriter("Hi.txt"));
      writer.print("Hi");
      writer.flush();
      writer.close();
    }
    
    при выполнении следующего метода создается файл Hi.txt с содержимым «Hi». - теперь вы знаете, как создать файл и что - нибудь в него записать
    
    3. public int wordCount(String fileName) {
      try {
          File file = new File(fileName);
          Scanner scanner = new Scanner(file);
          int i = 0;
          while (scanner.hasNext()) {
            scanner.next();
            ++i;
          }
          scanner.close();
          return i;
          } catch (FileNotFoundException e) {
            e.printStackTrace();
            return 0;
          }
        }
        
        этот код считает слова в файле. Гарантируется, что файл существует
        
    4. не забывайте закрывать файлы в конце вашей программы
    
    про остальное мельком посмотрите на страничке учебнике - там оч кратко про все написано - просто пробегите глазами.
    
3) Исключения
      Приведите пример кода, при выполнении которого возникает исключение FileNotFoundException.
      throw new FileNotFoundException(); 
      Это пример задания, которое может у вас быть 

      Немного теории:
         ошибка синтаксиса приведет к ошибке компиляции (compile time error)
         
         JVM выбрасывает исключение - прерывает исполнение текущего контекста и передает управление вышестоящему контексту
         Когда выбрасывается исключение JVM выполняет следующие действия:
                1. создаёт объект исключения;
                2. текущий поток исполнения останавливается, и ссылка на объект исключения "выталкивается" из текущего контекста.
         
         Пару слов о throw:
         Vожно послать информацию об ошибке в вышестоящий контекст с помощью создания объекта исключения, представляющего вашу информацию и «выбросить» его из вашего контекста принудительно. 
         Это называется выбрасыванием исключения. Это выглядит так:
         if(t == null) throw new NullPointerException();
         (можете почитать страничку в учебнике, а я иду дальше);
         
4) Logcat
    Что такое LogCat вы знаете, а даже если нет, прочитайте нет - https://developer.alexanderklimov.ru/android/debug/logcat.php?ysclid=ldkggxzici872252034
      Log.e() - ошибки (error)
      Log.w() - предупреждения (warning)
      Log.i() - информация (info)
      Log.d() - отладка (degub)
      Log.v() - подробности (verbose)
      Log.wtf() - очень серьёзная ошибка! 
      
      log...(TAG, message)
      1 - ый параметр метода (TAG)
      2 - сообщение для записи в журнале (message)
      Пример сообщения: 12-11 20:11:12.272 32347-32347/? I/INFO: info
          12-11 20:11:12.272 - Date/Time
          32347-32347 - Process & Thread IDs
          ? - Package name
          INFO Tag
          info - Message;
          
5) Throws
     В учебнике есть страничка - ключевое слово throws, читаем и в принципе все;
     При этом компилятор должен знать, 
     что данный метод может генерировать исключение ArithmeticException. Исключение обрабатывать не нужно.
     это значит, что сигнатура метода будет содержать throws ArithmeticException;
     
6) Программа с try catch
      Для начала: критический блок - секция кода, в котором может возникнуть исключение и за которой следует код, обрабатывающий это исключение.
      try catch - это критический блок

      Блок проверки — это обычный блок, предваряемый ключевом словом try
      Обработчик «заглушка». Можно создать обработчик, «ловящий» все типы исключений. 
      Для этого в блоке catch необходимо перехватить исключение базового типа Exception
      
7) Фрагменты
    onCreate(): вызывается при создании фрагмента; 
        здесь инициализируются компоненты, которые нужно восстановить при возобновлении работы фрагмента после остановки;
    onCreateView(): вызывается, когда нужно «нарисовать» фрагмент на экране в первый раз; 
        этот метод должен возвращать представление (View), которое является корневым для вашего фрагмента;
    onPause(): вызывается, когда пользователь покидает фрагмент и он (фрагмент) может быть уничтожен; 
        здесь следует сохранить несохраненные данные, поскольку обратно к фрагменту пользователь может не вернуться.
            
        onPause() - Пользователь не может взаимодействовать с фрагментом, но часть фрагмента видима пользователю
        onDetach() - Вызывается, когда фрагмент отвязывается от активности
        onDestroy() - Вызывается перед тем, как фрагмент будет уничтожен системой
        onStop() - Фрагмент становится не видим пользователю
        onDestroyView() - Вызывается, когда набор компонентов удаляется из фрагмента
        
        Фрагменты в разметке мне не нравятся, думаю вам тоже. Поэтому я расскажу про FragmentManager
        (но если вы хотите fragment - ы в разметке - https://developer.alexanderklimov.ru/android/fragment.php?ysclid=ldklq1puae397180981)
        ( + есть страничка в учебнике)
        
        Фрагмент всегда должен быть встроен в Activity, и на его жизненный цикл напрямую влияет жизненный цикл Activity.

        Например, когда активность приостановлена, в том же состоянии находятся и все фрагменты внутри нее. 
        А когда активность уничтожается, уничтожаются и все фрагменты. 
        
        Про жизненный цикл фрагмента вы можете почитать в учебнике - там есть отдельная страничка, где написано про каждый callback
        
        Последнее: про fragments много написано в учебнике - все проекты выложу на свой github (потыкаю). Про FragmentManager расскажу в другом файлике
        Ибо загружать этот пока не нужно.
        
8) Внутренние и анонимные классы
   Про классы хорошо написано в учебнике - там коротко и понятно. Читаните
   
   На заметку.
   Внутренние классы - члены - ограничения, которые на них действуют - вранье!!!!
   
   Про локальные классы
   они видны только в пределах блока, в котором объявлены (внутри фигурных скобок);
   они не могут содержать в себе статических объявлений за исключением констант — static final.
   ЗАПОМНИТЬ: В JAVA ДО 8 ВЕРСИИ ИЗ ЛОКАЛЬНОГО ВНУТРЕННЕГО КЛАССА МОЖНО БЫЛО ОБРАЩАТЬСЯ ТОЛЬКО К ЛОКАЛЬНЫМ FINAL ПЕРЕМЕНННЫМ
   
10) Методы по управлению потоками
  Прочитайте про это в теме про потоки - хорошо написано.
  Тут самое важное
  
  sleep - приостановить поток на указаннное время
  notify - уведомить потоки ожидающих на мониторе 
  join - приостановить текущий поток до завершения указанного
  start - запустить поток на выполнение (run просто выполняет метод run)
  
  остально есть в учебнике - просто открываете и смотрите, если что не так
  
11) Программа с потоками
    переопределяете метод run() и делаете задание - все просто 
    
12) Canvas и рисунки
  
  Про это хорошо написано в учебнике - 1 страницой. Также я выложу проект, в котором будут все необходимые методы
  
13) SurfaceView, SurfaceHolder.Callback и его методы

  surfaceDestroyed (SurfaceHolder holder) - метод вызывается перед уничтожением поверхности 
  surfaceChanged (SurfaceHolder holder, int format, int width, int height) - метод вызывается после структурных изменений поверхности 
  surfaceCreated (SurfaceHolder holder) - метод вызывается сразу после создания поверхности 
  
  Прикреплю проект на эту - там все заккоменчу. Открываем и юзаем
  Для тех, кто хочет покопаться - посмотрите https://github.com/NikitaTropin3536/Mobile-development-Java---projects.git
  Это дз, где шарик двигается по экрану.
  Потыкайте код и псомотрите, что происходит в каждом методе.
  
14) Android приложение
    Начинаем кр - переходим туда, где хранится приложение, копим ссылку
    открываем AS - какой - то проект - FILE - NEW - Project from version control
    вставляем то, что скопипастили - clone
    у нас загружается проект - мы идем ботать другие задания
    Когда закончили с ними - переходим в AS и пилим проект 
    
    Рекомендую вам заранее открыть странички со шпорами оп созданию потоков, фрагметов, canvas
    
    Скоррре всего что - то из этого и будет.
    
    Тут проверяют ваши скиллы, так что удачи!
  
  
  ПРО
  9) Потоки в Android 
  FragmentManager 
  Handler
  AsyncTask
  WorkManager
  
 я напишу в другом файле 
